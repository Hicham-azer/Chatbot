import openai
import os
import json

SYSTEM_MESSAGE = os.getenv('SYSTEM_MESSAGE')

def check_moderation(user_input):
    """
    Check user input for moderation using OpenAI's Moderation API.

    Args:
        user_input (str): The user input to be checked for moderation.

    Returns:

        bool: True if the input is flagged for moderation, False otherwise.
    """
    # Call OpenAI's Moderation API to check the user input for moderation
    moderation_output = openai.Moderation.create(user_input)
    
    # Extract the moderation results from the API response
    moderation_results = moderation_output["results"][0]
    
    # Get the flagged status of the input
    input_status = moderation_results["flagged"]
    
    # Return the flagged status of the input
    return input_status


def get_completion_from_messages(messages, model="gpt-3.5-turbo", temperature=0):
    """
    Generate a text completion based on a list of messages using the OpenAI GPT-3.5 model.

    Args:
        messages (list): A list of message objects in a conversation.
        model (str): The model to use for completion (default: "gpt-3.5-turbo").
        temperature (float): The randomness of the generated output (default: 0).

    Returns:
        str: The generated text completion.
    """
    # Create a chat completion request using the provided messages and settings
    response = openai.ChatCompletion.create(
        model=model,
        messages=messages,
        temperature=temperature,
    )
    # Extract and return the content of the generated completion
    return response.choices[0].message["content"]

def collect_messages(user_input, context):
    """
    Collect user input, generate an assistant response, and manage conversation history.

    Args:
        user_input (str): The input provided by the user.
        context (list): A list of message objects in a conversation.

    Returns:
        str: The response generated by the assistant.
    """
    # Add user input to the conversation history
    prompt = user_input
    context.append({'role':'user', 'content':f"{prompt}"})

    # Generate an assistant response based on the conversation history
    response = get_completion_from_messages(context) 

    # Add assistant response to the conversation history
    context.append({'role':'assistant', 'content':f"{response}"})

    # Return the assistant response
    return response

def save_conversation_file(conversation, conversation_name, content_directory):
    """
    Store the JSON file.

    Args:
        conversation (list): The conversation to be saved, represented as a list of message objects.
        conversation_name (str): The desired name for the conversation file (without the extension).
        content_directory (str) : The name of the directory where the conversations are saved.

    Returns:
        None
    """
    # Open the specified file in write mode and save the conversation as JSON
    file_path = os.path.join(content_directory, f'{conversation_name}.json')
    with open(file_path, 'w') as f:
        json.dump(conversation, f)



def load_conversation(filename, content_directory):
    """
    Load a conversation from a JSON file.

    Args:
        filename (str): The name of the JSON file containing the conversation (without the extension).
        content_directory (str) : The name of the directory where the conversations are saved.

    Returns:
        list: The loaded conversation, represented as a list of message objects.
    """
    # Open the specified file in read mode, read its content, and parse it as JSON
    file_path = os.path.join(content_directory, f'{filename}.json')
    with open(file_path, "r") as file:
        conversation = file.read()
        conversation = json.loads(conversation)
    
    # Return the loaded conversation
    return conversation



def print_file_names(content_directory):
    """
    Prints the names of files in a given directory.
    
    Args:
        directory_path (str): Path to the directory containing the files.
        
    Returns:
        int: The number of files in the directory.
    """
    
    # List all files in the directory
    files = os.listdir(content_directory)

    # Get the total number of files
    number_files = len(files)
    
    # Check if there are no files in the directory
    if number_files != 0 : 
        # Iterate through the list of files and print their names
        print("List of Previous Conversation :")
        for file in files:
            file_name,_ = os.path.splitext(file)  # Split file name and extension
            print(file_name)
    
    return number_files

def print_conversation(conversation_list):
    """
    Prints the role and content from a list of conversation dictionaries.
    
    Args:
        conversation_list (list): List of dictionaries containing 'role' and 'content'.
    Returns:
        None
    """
    
    # Iterate through the list of dictionaries from the frist postion to ignore thesystem message. 
    for entry in conversation_list[1:]:
        role = entry['role']
        content = entry['content']
        # Replace 'user' with 'you' and 'assistant' with 'chatbot'
        role = role.replace('user', 'you').replace('assistant', 'chatbot')
        # print role and content
        print(f"{role} : {content}\n")

def save_conversation(conversation, content_directory):
    """
    Save a conversation to a file.

    Args:
        conversation (str): The conversation to be saved.
        content_directory (str) : The name of the directory where the conversations are saved.
    Returns:
        None
    """
    print("Chatbot: Give a name for this conversation")
    
    while True:
        try:
            # Prompt the user to input a name for the conversation file
            user_input = input("You: ")
            
            # Save the conversation using the provided context and user input
            save_conversation_file(conversation, user_input, content_directory)
            
            # Exit the loop if the conversation is successfully saved
            break
        except Exception:
            print("File name invalid, please try with another one.")



def conversation_loop(conversation, content_directory):
    """
    Run a conversation loop where the user interacts with a chatbot.

    Args:
        conversation (list): A list to store the conversation messages.
        content_directory (str) : The name of the directory where the conversations are saved.
    Returns:
        None
    
    """
    while True:
        user_input = input("You: ")
        

               
        # Check if the user wants to exit the conversation
        if user_input.lower() == "exit":
            print('Chatbot: Do you want to save this conversation? Answer with a \'yes\' or \'no\' ')
            user_input = input("You: ")
            if user_input == 'yes' :
                save_conversation(conversation, content_directory)  # Save the conversation
            break
        try :
            input_statut = check_moderation(user_input)
            if input_statut == False :    
                response = collect_messages(user_input, conversation)  # Generate the assistant's response
                print("Chatbot:", response)
            else : 
                print('Chatbot: I\'m sorry, but your input violates our content guidelines.')
        except Exception as e :
            print(f"An error occurred: {e}")

def recover_conversation(content_directory):
    """
    Recover and load a conversation from saved files.

    Args:
        content_path (str): The path to the directory containing saved conversation files.
    
    Returns:
        Conversation (list) : The list of all the messages from the old conversation

    """
 
    # Get the number of files in the content path and display them
    number_files = print_file_names(content_directory)
    
    # If there are files in the content path
    if number_files != 0:
        # Prompt the user to provide the name of the conversation
        print("Chatbot: What is the name of the conversation?")
        while True:
            try:
                # Prompt the user for input (user response) and load the conversation
                user_input = input("You: ")
                context = load_conversation(user_input, content_directory)
                break
            except FileNotFoundError:
                # Handle the case where the file name provided by the user is invalid
                print('Chatbot: The file name is invalid. Please try again.')

        # Display a message indicating that the conversation has been loaded
        print("Chatbot: Conversation loaded")
        print('--------------------------------------------------------------------------')
        
        # Display the loaded conversation
        print_conversation(context)

    else : 
        print('Chatbot: There is no saved conversation! Let\'s start a new one')
        context = json.loads(SYSTEM_MESSAGE)
    
    # Return the loaded conversation 
    return context

