import openai
import os
import json
from dotenv import load_dotenv, find_dotenv
_ = load_dotenv(find_dotenv())

openai.api_key = os.getenv('OPENAI_API_KEY')
content_path = r'C:\Users\hicha\chatbot\content'




def get_completion_from_messages(messages, model="gpt-3.5-turbo", temperature=0):
    """
    Generate a text completion based on a list of messages using the OpenAI GPT-3.5 model.

    Args:
        messages (list): A list of message objects in a conversation.
        model (str): The model to use for completion (default: "gpt-3.5-turbo").
        temperature (float): The randomness of the generated output (default: 0).

    Returns:
        str: The generated text completion.
    """
    # Create a chat completion request using the provided messages and settings
    response = openai.ChatCompletion.create(
        model=model,
        messages=messages,
        temperature=temperature,
    )
    # Extract and return the content of the generated completion
    return response.choices[0].message["content"]

def collect_messages(user_input, context):
    """
    Collect user input, generate an assistant response, and manage conversation history.

    Args:
        user_input (str): The input provided by the user.
        context (list): A list of message objects in a conversation.

    Returns:
        str: The response generated by the assistant.
    """
    # Add user input to the conversation history
    prompt = user_input
    context.append({'role':'user', 'content':f"{prompt}"})

    # Generate an assistant response based on the conversation history
    response = get_completion_from_messages(context) 

    # Add assistant response to the conversation history
    context.append({'role':'assistant', 'content':f"{response}"})

    # Return the assistant response
    return response

def SaveConversationFile(conversation, conversation_name):
    """
    Save a conversation to a JSON file.

    Args:
        conversation (list): The conversation to be saved, represented as a list of message objects.
        conversation_name (str): The desired name for the conversation file (without the extension).

    Returns:
        None
    """
    # Open the specified file in write mode and save the conversation as JSON
    file_path = os.path.join(content_path, f'{conversation_name}.json')
    with open(file_path, 'w') as f:
        json.dump(conversation, f)



def load_conversation(filename):
    """
    Load a conversation from a JSON file.

    Args:
        filename (str): The name of the JSON file containing the conversation (without the extension).

    Returns:
        list: The loaded conversation, represented as a list of message objects.
    """
    # Open the specified file in read mode, read its content, and parse it as JSON
    file_path = os.path.join(content_path, f'{filename}.json')
    with open(file_path, "r") as file:
        conversation = file.read()
        conversation = json.loads(conversation)
    
    # Return the loaded conversation
    return conversation



def print_file_names(directory_path):
    """
    Prints the names of files in a given directory.
    
    Args:
        directory_path (str): Path to the directory containing the files.
        
    Returns:
        int: The number of files in the directory.
    """
    
    # List all files in the directory
    files = os.listdir(directory_path)

    # Get the total number of files
    number_files = len(files)
    
    # Check if there are no files in the directory
    if number_files != 0 : 
        # Iterate through the list of files and print their names
        print("List of Previous Conversation :")
        for file in files:
            file_name,_ = os.path.splitext(file)  # Split file name and extension
            print(file_name)
    
    return number_files

def print_conversation(conversation_list):
    """
    Prints the role and content from a list of conversation dictionaries.
    
    Args:
        conversation_list (list): List of dictionaries containing 'role' and 'content'.
    """
    
    # Iterate through the list of dictionaries and print role and content
    for entry in conversation_list:
        role = entry['role']
        content = entry['content']
        # Replace 'user' with 'you' and 'assistant' with 'chatbot'
        role = role.replace('user', 'you').replace('assistant', 'chatbot')
        print(f"{role} : {content}\n")

def save_conversation(context,user_input):
    print("Chatbot: Give a name for this conversation")
    while True :
        try : 
            user_input = input("You: ")
            SaveConversationFile(context, user_input)  # Save the conversation
            break
        except Exception :
            print(f"File name unvalid, please try with another one.")


def conversation_loup(context):
    while True:
        user_input = input("You: ")
        

               
        # Check if the user wants to exit the conversation
        if user_input.lower() == "exit":
            print('Chatbot: Do you want to save this conversation? Answer with a \'yes\' or \'no\' ')
            user_input = input("You: ")
            if user_input == 'yes' :
                save_conversation(context, user_input)  # Save the conversation
            break

        try :
            response = collect_messages(user_input, context)  # Generate the assistant's response
            print("Chatbot:", response)

        except Exception as e :
            print(f"An error occurred: {e}")

def recover_conversation():


    
    # Get the number of files in the content path and display them
    number_files = print_file_names(content_path)
    
    # If there are files in the content path
    if number_files != 0:
        # Prompt the user to provide the name of the conversation
        print("Chatbot: What is the name of the conversation?")
        while True:
            try:
                # Prompt the user for input (user response) and load the conversation
                user_input = input("You: ")
                context = load_conversation(user_input)
                break
            except FileNotFoundError:
                # Handle the case where the file name provided by the user is invalid
                print('Chatbot: The file name is invalid. Please try again.')

        # Display a message indicating that the conversation has been loaded
        print("Chatbot: Conversation loaded")
        print('--------------------------------------------------------------------------')
        
        # Display the loaded conversation
        print_conversation(context)

    else : 
        print('Chatbot: There is no saved conversation! Let\'s start a new one')
        context = []
    
    # Return the loaded conversation context
    return context




def main():
    """
    Main function to interact with the chatbot, manage conversation, and save/load conversations.

    Returns:
        None
    """

    print("Chatbot: Welcome to your Chatbot. Do you want to load a conversation? Answer with a \'yes' or \'no'") # Check if the user wants to load a conversation
    while True :

        user_input = input("You: ")

        if user_input.lower() == 'yes':
            context = recover_conversation()
            break
        
        elif user_input.lower() == 'no' :
            context = []
            print('Chatbot: Ok! How can I assist you today?')
            break
        
        else :
            print('Chatbot: You shloud answer with a \'yes\' or \'no\'')

    conversation_loup(context)

    return

main()


    





